{
    "CP-SNIPPET": {
        "prefix": "SNIPPET",
        "body": [
            "/*",
            "    $1.cpp",
            "",
            "    $2",
            "*/",
            "",
            "#include <iostream>",
            "#include <cstdio>",
            "#include <cassert>",
            "#include <chrono>",
            "#include <random>",
            "#include <cstdint>",
            "#include <string>",
            "#include <array>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <set>",
            "#include <unordered_map>",
            "#include <unordered_set>",
            "#include <queue>",
            "#include <stack>",
            "#include <deque>",
            "#include <numeric>",
            "#include <utility>",
            "#include <algorithm>",
            "#include <bitset>",
            "#include <cmath>",
            "",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "",
            "#define nl '\\n'",
            "",
            "using namespace std;",
            "using namespace __gnu_pbds;",
            "",
            "using ll = long long;",
            "using vi = std::vector<int>;",
            "using pii = std::pair<int, int>;",
            "",
            "////////// SNIPPET BEGIN //////////",
            "////////// SNIPPET END //////////",
            "",
            "int main() {",
            "    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);",
            "",
            "    $0",
            "}"
        ],
        "description": "Snippet for a snippet file. The most meta of them all."
    },
    "CP-CF": {
        "prefix": "CF",
        "body": [
            "#include <iostream>",
            "#include <cstdio>",
            "#include <cassert>",
            "#include <chrono>",
            "#include <random>",
            "#include <cstdint>",
            "#include <string>",
            "#include <array>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <set>",
            "#include <unordered_map>",
            "#include <unordered_set>",
            "#include <queue>",
            "#include <stack>",
            "#include <deque>",
            "#include <numeric>",
            "#include <utility>",
            "#include <algorithm>",
            "#include <bitset>",
            "#include <cmath>",
            "",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "",
            "#define nl '\\n'",
            "",
            "using namespace std;",
            "using namespace __gnu_pbds;",
            "",
            "using ll = long long;",
            "using vi = std::vector<int>;",
            "using pii = std::pair<int, int>;",
            "",
            "void solve() {",
            "    $0",
            "}",
            "",
            "int main() {",
            "    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);",
            "    ",
            "    int t; std::cin >> t;",
            "    while (t--) {",
            "        solve();",
            "    }",
            "}"
        ],
        "description": "C++ template for Codeforces problems."
    },
    "CP-USACO": {
        "prefix": "USACO",
        "body": [
            "#include <iostream>",
            "#include <cstdio>",
            "#include <cassert>",
            "#include <chrono>",
            "#include <random>",
            "#include <cstdint>",
            "#include <string>",
            "#include <array>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <set>",
            "#include <unordered_map>",
            "#include <unordered_set>",
            "#include <queue>",
            "#include <stack>",
            "#include <deque>",
            "#include <numeric>",
            "#include <utility>",
            "#include <algorithm>",
            "#include <bitset>",
            "#include <cmath>",
            "",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "",
            "#define nl '\\n'",
            "",
            "using namespace std;",
            "using namespace __gnu_pbds;",
            "",
            "using ll = long long;",
            "using vi = std::vector<int>;",
            "using pii = std::pair<int, int>;",
            "",
            "int main() {",
            "    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);",
            "    ",
            "    $0",
            "}"
        ],
        "description": "C++ template for USACO problems. No `t` test cases, as in Codeforces."
    },
    "CP-FILEIO": {
        "prefix": "FILEIO",
        "body": [
            "std::freopen(\"$1.in\", \"r\", stdin);",
            "std::freopen(\"$1.out\", \"w\", stdout);",
            "",
            "$0"
        ],
        "description": "Allows C++ file I/O by redirecting to standard input and output."
    },
    "CP-TIMER": {
        "prefix": "TIMER",
        "body": [
            "// https://www.learncpp.com/cpp-tutorial/timing-your-code/",
            "class Timer {",
            "private:",
            "    using Clock = std::chrono::steady_clock;",
            "    using Second = std::chrono::duration<double, std::ratio<1>>;",
            "",
            "    std::chrono::time_point<Clock> m_beg { Clock::now() };",
            "",
            "public:",
            "    void reset() {",
            "        m_beg = Clock::now();",
            "    }",
            "",
            "    double elapsed() const {",
            "        return std::chrono::duration_cast<Second>(Clock::now() - m_beg).count();",
            "    }",
            "};",
            "$0"
        ],
        "description": "A C++ Timer class."
    },
    "CP-INPUTARRAY": {
        "prefix": "INPUTARRAY",
        "body": [
            "std::vector<int> a(n);",
            "for (int i = 0; i < n; ++i) {",
            "    std::cin >> a[i];",
            "}",
            "$0"
        ],
        "description": "Reads `n` integers from standard input into a vector named `a`."
    },
    "CP-GOSPERHACK": {
        "prefix": "GOSPERHACK",
        "body": [
            "// http://programmingforinsomniacs.blogspot.com/2018/03/gospers-hack-explained.html",
            "int set = (1 << k) - 1;",
            "int limit = (1 << n);",
            "while (set < limit) {",
            "    // use the subset",
            "    $0",
            "",
            "    int c = set & -set;",
            "    int r = set + c;",
            "    set = (((r ^ set) >> 2) / c) | r;",
            "}"
        ],
        "description": "Iterates through all subsets of size `k` from `n` elements using bitmasks in increasing order."
    },
    "CP-SAFEMAP": {
        "prefix": "SAFEMAP",
        "body": [
            "// https://codeforces.com/blog/entry/62393",
            "struct custom_hash {",
            "    static std::uint64_t splitmix64(std::uint64_t x) {",
            "        // http://xorshift.di.unimi.it/splitmix64.c",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            "",
            "    std::size_t operator()(std::uint64_t x) const {",
            "        static const std::uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "    }",
            "};",
            "",
            "template <typename T>",
            "using safe_umap = unordered_map<long long, T, custom_hash>;",
            "",
            "template <typename T>",
            "using safe_gp_hash = gp_hash_table<long long, T, custom_hash>;",
            "$0"
        ],
        "description": "Hash map data structure safe from hacking due to randomization to prevent forced collisions."
    },
    "CP-INDEXEDSET": {
        "prefix": "INDEXEDSET",
        "body": [
            "// operations: insert, erase (takes a pointer), find, find_by_order (returns a pointer), order_of_key",
            "template <typename T>",
            "using indexed_set = __gnu_pbds::tree<T, __gnu_pbds::null_type, std::less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;",
            "// use pair<int, int> with indices as second for multiset",
            "",
            "template <typename T, typename U>",
            "using indexed_map = __gnu_pbds::tree<T, U, std::less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;",
            "$0"
        ],
        "description": "Augmented set with support for finding n-th element, or the index of an element."
    },
    "CP-LINECONTAINER": {
        "prefix": "LINECONTAINER",
        "body": [
            "// https://github.com/kth-competitive-programming/kactl/blob/main/content/data-structures/LineContainer.h",
            "struct Line {",
            "    mutable ll m, b, p;",
            "    bool operator<(const Line& o) const { return m < o.m; }",
            "    bool operator<(ll x) const { return p < x; }",
            "};",
            "",
            "struct LineContainer : std::multiset<Line, std::less<>> {",
            "    // (for doubles, use INF = 1/.0, div(a,b) = a/b)",
            "    static const ll INF = LLONG_MAX;",
            "",
            "    ll div(ll a, ll b) {",
            "        // floored division",
            "        return a / b - ((a ^ b) < 0 && a % b);",
            "    }",
            "",
            "    bool isect(iterator x, iterator y) {",
            "        if (y == end()) {",
            "            x->p = INF;",
            "            return 0;",
            "        }",
            "        if (x->m == y->m)",
            "            x->p = (x->b > y->b ? INF : -INF);",
            "        else",
            "            x->p = div(y->b - x->b, x->m - y->m);",
            "        return (x->p >= y->p);",
            "    }",
            "",
            "    void add(ll m, ll b) {",
            "        auto z = insert({m, b, 0}), y = z++, x = y;",
            "        while (isect(y, z))",
            "            z = erase(z);",
            "        if (x != begin() && isect(--x, y))",
            "            isect(x, y = erase(y));",
            "        while ((y = x) != begin() && (--x)->p >= y->p)",
            "            isect(x, erase(y));",
            "    }",
            "",
            "    ll query(ll x) {",
            "        assert(!empty());",
            "        auto l = *lower_bound(x);",
            "        return l.m * x + l.b;",
            "    }",
            "};",
            "$0"
        ],
        "description": "Container to add lines of the form m*x + b, and query maximum y-coordinates at given x."
    },
    "CP-RMQ": {
        "prefix": "RMQ",
        "body": [
            "template <typename T>",
            "struct RMQ {",
            "    // jmp[lvl][j] stores the minimum value and index (ties broken leftwards) in [j, j + 2^lvl)",
            "    std::vector<std::vector<std::pair<T, int>>> jmp;",
            "    ",
            "    RMQ(const std::vector<T>& V) : jmp(1, std::vector<std::pair<T, int>>(V.size())) {",
            "        for (int i = 0; i < V.size(); ++i) ",
            "            jmp[0][i] = { V[i], i };",
            "        for (int pw = 1, k = 1; pw * 2 <= static_cast<int>(V.size()); pw *= 2, ++k) {",
            "            jmp.emplace_back(static_cast<int>(V.size()) - pw * 2 + 1);",
            "            for (int j = 0; j < jmp[k].size(); ++j) ",
            "                jmp[k][j] = min(jmp[k - 1][j], jmp[k - 1][j + pw]);",
            "        }",
            "    }",
            "",
            "    std::pair<T, int> query(int l, int r) {",
            "        assert (l <= r);",
            "        int lvl = 31 - __builtin_clz(r - l + 1);",
            "        return min(jmp[lvl][l], jmp[lvl][r - (1 << lvl) + 1]);",
            "    }",
            "};",
            "$0"
        ],
        "description": "One-dimensional range minimum queries using a sparse table."
    },
    "CP-FENWICK": {
        "prefix": "FENWICK",
        "body": [
            "struct Fenwick {",
            "    // 1-indexed internally",
            "    int n;",
            "    std::vector<ll> bit;",
            "",
            "    Fenwick(int n) {",
            "        this->n = n + 1;",
            "        bit.assign(n + 1, 0LL);",
            "    }",
            "",
            "    Fenwick(std::vector<ll> a) : Fenwick(a.size()) {",
            "        for (size_t i = 0; i < a.size(); i++)",
            "            update(i, a[i]);",
            "    }",
            "",
            "    // query operations are inclusive",
            "    ll prefix(int idx) {",
            "        ll ret = 0LL;",
            "        for (++idx; idx > 0; idx -= idx & -idx)",
            "            ret += bit[idx];",
            "        return ret;",
            "    }",
            "",
            "    ll sum(int l, int r) {",
            "        if (l > r) return 0LL;",
            "        if (l == 0) return prefix(r);",
            "        return prefix(r) - prefix(l - 1);",
            "    }",
            "",
            "    void update(int idx, ll delta) {",
            "        for (++idx; idx < n; idx += idx & -idx)",
            "            bit[idx] += delta;",
            "    }",
            "};"
        ],
        "description": "Fenwick tree for range sums and point updates."
    },
    "CP-SEGTREE": {
        "prefix": "SEGTREE",
        "body": [
            "template <typename T>",
            "T op(T a, T b) {",
            "    return a + b; /* combine answers (any associative op) */",
            "}",
            "",
            "template <typename T>",
            "T e() {",
            "    return 0; /* initial value for queries (e.g. 0 for sum, -inf for max) */",
            "}",
            "",
            "template <typename T, T(*op)(T, T), T(*e)()>",
            "struct SegTree {",
            "    // e.g. use SegTree<ll, op, e> tree(a);",
            "    int n;",
            "    std::vector<T> tree;",
            "",
            "    SegTree(int n) {",
            "        this->n = n;",
            "        tree.assign(4*n+1, e());",
            "    }",
            "",
            "    SegTree(std::vector<T> a) : SegTree(a.size()) {",
            "        build(a, 1, 0, n-1);",
            "    }",
            "",
            "    void build(std::vector<T>& a, int idx, int tl, int tr) {",
            "        if (tl > tr) return;",
            "        if (tl == tr) {",
            "            tree[idx] = a[tl];",
            "        } else {",
            "            int tm = (tl+tr)/2;",
            "            build(a, 2*idx, tl, tm);",
            "            build(a, 2*idx+1, tm+1, tr);",
            "            tree[idx] = op(tree[2*idx], tree[2*idx+1]);",
            "        }",
            "    }",
            "",
            "    T query(int idx, int tl, int tr, int l, int r) {",
            "        if (l > r) return e();",
            "        if (l == tl && r == tr) return tree[idx];",
            "        int tm = (tl+tr)/2;",
            "        return op(",
            "            query(2*idx, tl, tm, l, min(r, tm)),",
            "            query(2*idx+1, tm+1, tr, max(l, tm+1), r)",
            "        );",
            "    }",
            "",
            "    void update(int idx, int tl, int tr, int pos, T new_val) {",
            "        if (tl == tr) {",
            "            tree[idx] = new_val;",
            "        } else{",
            "            int tm = (tl+tr)/2;",
            "            if (pos <= tm)",
            "                update(2*idx, tl, tm, pos, new_val);",
            "            else",
            "                update(2*idx+1, tm+1, tr, pos, new_val);",
            "            tree[idx] = op(tree[2*idx], tree[2*idx+1]);",
            "        }",
            "    }",
            "",
            "    T query(int l, int r) {",
            "        // queries are *inclusive* [l,r]",
            "        return query(1, 0, n-1, l, r);",
            "    }",
            "",
            "    void update(int pos, T new_val) {",
            "        update(1, 0, n-1, pos, new_val);",
            "    }",
            "",
            "    void print() {",
            "        for (T x : tree) cout << x << \" \";",
            "        cout << nl;",
            "    }",
            "};"
        ],
        "description": "Standard segment tree that supports range queries and point setting."
    },
    "CP-ERASTOSTHENES": {
        "prefix": "ERASTOSTHENES",
        "body": [
            "constexpr int MAX_PR = 1e7;",
            "std::bitset<MAX_PR> is_prime;",
            "",
            "// REMEMBER TO RUN THIS FUNCTION!",
            "void compute_primes() {",
            "    is_prime.set();",
            "    is_prime[0] = false;",
            "    is_prime[1] = false;",
            "",
            "    for (int i = 4; i < MAX_PR; i += 2)",
            "        is_prime[i] = false;",
            "",
            "    for (int i = 3; i * i < MAX_PR; i += 2)",
            "        if (is_prime[i])",
            "            for (int j = i * i; j < MAX_PR; j += i * 2)",
            "                is_prime[j] = 0;",
            "}",
            "$0"
        ],
        "description": "Sieve for generating primes up to `MAX_PR`."
    },
    "CP-MODINT": {
        "prefix": "MODINT",
        "body": [
            "template <ll N>",
            "struct ModInt {",
            "    ll value;",
            "",
            "    ModInt(const ll x = 0) : value { x % N } {",
            "        if (value < 0) value += N;",
            "    }",
            "    ModInt(const ll n, const ll d) : value { 0 } {",
            "        *this += n; *this /= d;",
            "    }",
            "",
            "    ModInt operator+(const ModInt& other) const noexcept {",
            "        return ModInt(*this) += other;",
            "    }",
            "    ModInt operator-(const ModInt& other) const noexcept {",
            "        return ModInt(*this) -= other;",
            "    }",
            "    ModInt operator*(const ModInt& other) const noexcept {",
            "        return ModInt(*this) *= other;",
            "    }",
            "    ModInt operator/(const ModInt& other) const noexcept {",
            "        return ModInt(*this) /= other;",
            "    }",
            "",
            "    ModInt& operator+=(const ModInt& other) noexcept {",
            "        value += other.value;",
            "        if (value >= N) value -= N;",
            "        return *this;",
            "    }",
            "    ModInt& operator-=(const ModInt& other) noexcept {",
            "        value -= other.value;",
            "        if (value < 0) value += N;",
            "        return *this;",
            "    }",
            "    ModInt& operator*=(const ModInt& other) noexcept {",
            "        value = value * other.value % N;",
            "        return *this;",
            "    }",
            "    ModInt& operator/=(const ModInt& other) noexcept {",
            "        return *this *= other.inv();",
            "    }",
            "",
            "    ModInt pow(ll e) const noexcept {",
            "        ModInt res(1), tmp(*this);",
            "        while (e) {",
            "            if (e & 1) res *= tmp;",
            "            tmp *= tmp;",
            "            e >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "    ModInt inv() const noexcept {",
            "        return pow(N - 2);",
            "    }",
            "",
            "    explicit operator int() const {",
            "        return value;",
            "    }",
            "    friend std::ostream& operator<<(std::ostream& os, const ModInt& obj) {",
            "        return os << obj.value;",
            "    }",
            "    friend std::istream& operator>>(std::istream& is, ModInt& obj) {",
            "        ll t; is >> t;",
            "        obj = ModInt(t);",
            "        return is;",
            "    }",
            "};",
            "constexpr int MOD = 1e9 + 7; // CHANGE!",
            "using MI = ModInt<MOD>;"
        ],
        "description": "Allows easy integer modular arithmetic, modulo a constant prime."
    }
}