{
    "CP-SNIPPET": {
        "prefix": "SNIPPET",
        "body": [
            "/*",
            "    $1.cpp",
            "",
            "    $2",
            "*/",
            "",
            "#include <bits/stdc++.h>",
            "",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "",
            "#define nl '\\n'",
            "",
            "using namespace std;",
            "using namespace __gnu_pbds;",
            "",
            "using ll = long long;",
            "using vi = std::vector<int>;",
            "using pii = std::pair<int, int>;",
            "",
            "template <typename T, typename U>",
            "std::istream& operator>>(std::istream& in, std::pair<T, U>& pair) {",
            "    in >> pair.first >> pair.second;",
            "    return in;",
            "}",
            "",
            "template <typename T>",
            "std::istream& operator>>(std::istream& in, std::vector<T>& vec) {",
            "    for (T& x : vec) {",
            "        in >> x;",
            "    }",
            "    return in;",
            "}",
            "",
            "////////// SNIPPET BEGIN //////////",
            "////////// SNIPPET END //////////",
            "",
            "int main() {",
            "    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);",
            "",
            "    $0",
            "}"
        ],
        "description": "Snippet for a snippet file. The most meta of them all."
    },
    "CP-CF": {
        "prefix": "CF",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "",
            "#define nl '\\n'",
            "",
            "using namespace std;",
            "using namespace __gnu_pbds;",
            "",
            "using ll = long long;",
            "using vi = std::vector<int>;",
            "using pii = std::pair<int, int>;",
            "",
            "template <typename T, typename U>",
            "std::istream& operator>>(std::istream& in, std::pair<T, U>& pair) {",
            "    in >> pair.first >> pair.second;",
            "    return in;",
            "}",
            "",
            "template <typename T>",
            "std::istream& operator>>(std::istream& in, std::vector<T>& vec) {",
            "    for (T& x : vec) {",
            "        in >> x;",
            "    }",
            "    return in;",
            "}",
            "",
            "$1",
            "",
            "void solve() {",
            "    $0",
            "}",
            "",
            "int main() {",
            "    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);",
            "    ",
            "    int t; std::cin >> t;",
            "    while (t--) {",
            "        solve();",
            "    }",
            "}"
        ],
        "description": "C++ template for Codeforces problems."
    },
    "CP-USACO": {
        "prefix": "USACO",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "",
            "#define nl '\\n'",
            "",
            "using namespace std;",
            "using namespace __gnu_pbds;",
            "",
            "using ll = long long;",
            "using vi = std::vector<int>;",
            "using pii = std::pair<int, int>;",
            "",
            "template <typename T, typename U>",
            "std::istream& operator>>(std::istream& in, std::pair<T, U>& pair) {",
            "    in >> pair.first >> pair.second;",
            "    return in;",
            "}",
            "",
            "template <typename T>",
            "std::istream& operator>>(std::istream& in, std::vector<T>& vec) {",
            "    for (T& x : vec) {",
            "        in >> x;",
            "    }",
            "    return in;",
            "}",
            "",
            "$1",
            "",
            "int main() {",
            "    std::ios::sync_with_stdio(false); std::cin.tie(nullptr);",
            "    ",
            "    $0",
            "}"
        ],
        "description": "C++ template for USACO problems. No `t` test cases, as in Codeforces."
    },
    "CP-TIMER": {
        "prefix": "TIMER",
        "body": [
            "// https://www.learncpp.com/cpp-tutorial/timing-your-code/",
            "class Timer {",
            "private:",
            "    using Clock = std::chrono::steady_clock;",
            "    using Second = std::chrono::duration<double, std::ratio<1>>;",
            "",
            "    std::chrono::time_point<Clock> m_beg { Clock::now() };",
            "",
            "public:",
            "    void reset() {",
            "        m_beg = Clock::now();",
            "    }",
            "",
            "    double elapsed() const {",
            "        return std::chrono::duration_cast<Second>(Clock::now() - m_beg).count();",
            "    }",
            "};",
            "$0"
        ],
        "description": "A C++ Timer class."
    },
    "CP-FILEIO": {
        "prefix": "FILEIO",
        "body": [
            "std::freopen(\"$1.in\", \"r\", stdin);",
            "std::freopen(\"$1.out\", \"w\", stdout);",
            "",
            "$0"
        ],
        "description": "Allows C++ file I/O by redirecting to standard input and output."
    },
    "CP-DEBUG": {
        "prefix": "DEBUG",
        "body": [
            "template <typename T, typename U>",
            "std::ostream& operator<<(std::ostream& out, const std::pair<T, U>& pair) {",
            "    return out << \"(\" << pair.first << \", \" << pair.second << \")\";",
            "}",
            "",
            "template <typename T>",
            "std::ostream& operator<<(std::ostream& out, const std::vector<T>& vec) {",
            "    if (vec.empty()) {",
            "        out << \"[]\";",
            "        return out;",
            "    }",
            "    out << \"[\" << vec[0];",
            "    for (size_t i = 1; i < vec.size(); ++i) {",
            "        out << \", \" << vec[i];",
            "    }",
            "    out << \"]\";",
            "    return out;",
            "}",
            "",
            "template <typename T>",
            "std::ostream& operator<<(std::ostream& out, const std::deque<T>& deq) {",
            "    if (deq.empty()) {",
            "        out << \"[]\";",
            "        return out;",
            "    }",
            "    out << \"[\" << deq[0];",
            "    for (size_t i = 1; i < deq.size(); ++i) {",
            "        out << \", \" << deq[i];",
            "    }",
            "    out << \"]\";",
            "}",
            "",
            "template <typename T>",
            "std::ostream& operator<<(std::ostream& out, const std::unordered_set<T>& set) {",
            "    out << '{';",
            "    for (auto it = set.begin(); it != set.end(); it++) {",
            "        T element = *it;",
            "        out << element;",
            "        if (std::next(it) != set.end()) {",
            "            out << \", \";   ",
            "        }",
            "    }",
            "    return out << '}';",
            "}",
            "",
            "template <typename T, typename U>",
            "std::ostream& operator<<(std::ostream& out, const std::map<T, U>& map) {",
            "    out << '{';",
            "    for (auto it = map.begin(); it != map.end(); it++) {",
            "        std::pair<T, U> element = *it;",
            "        out << element.first << \": \" << element.second;",
            "        if (std::next(it) != map.end()) {",
            "            out << \", \";   ",
            "        }",
            "    }",
            "    return out << '}';",
            "}",
            "$0"
        ],
        "description": "Overloads ostream operators for standard types."
    },
    "CP-SAFEMAP": {
        "prefix": "SAFEMAP",
        "body": [
            "// https://codeforces.com/blog/entry/62393",
            "struct custom_hash {",
            "    static std::uint64_t splitmix64(std::uint64_t x) {",
            "        // http://xorshift.di.unimi.it/splitmix64.c",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            "",
            "    std::size_t operator()(std::uint64_t x) const {",
            "        static const std::uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "    }",
            "};",
            "",
            "template <typename T>",
            "using safe_umap = unordered_map<long long, T, custom_hash>;",
            "",
            "template <typename T>",
            "using safe_gp_hash = gp_hash_table<long long, T, custom_hash>;",
            "$0"
        ],
        "description": "Hash map data structure safe from hacking due to randomization to prevent forced collisions."
    },
    "CP-INDEXEDSET": {
        "prefix": "INDEXEDSET",
        "body": [
            "// operations: insert, erase (takes a pointer), find, find_by_order (returns a pointer), order_of_key",
            "template <typename T>",
            "using indexed_set = __gnu_pbds::tree<T, __gnu_pbds::null_type, std::less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;",
            "// use pair<int, int> with indices as second for multiset",
            "",
            "template <typename T, typename U>",
            "using indexed_map = __gnu_pbds::tree<T, U, std::less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;",
            "$0"
        ],
        "description": "Augmented set with support for finding n-th element, or the index of an element."
    },
    "CP-LINECONTAINER": {
        "prefix": "LINECONTAINER",
        "body": [
            "// https://github.com/kth-competitive-programming/kactl/blob/main/content/data-structures/LineContainer.h",
            "",
            "struct Line {",
            "    mutable ll m, b, p;",
            "    bool operator<(const Line& o) const { return m < o.m; }",
            "    bool operator<(ll x) const { return p < x; }",
            "};",
            "",
            "/**",
            " * Container to add lines of the form m*x + b, and query maximum y-coordinates at given x.",
            "*/",
            "struct LineContainer : std::multiset<Line, std::less<>> {",
            "    /// For doubles, use INF = 1/.0, div(a,b) = a/b.",
            "    static const ll INF = LLONG_MAX;",
            "",
            "    /// Floored division.",
            "    ll div(ll a, ll b) {",
            "        return a / b - ((a ^ b) < 0 && a % b);",
            "    }",
            "",
            "    bool isect(iterator x, iterator y) {",
            "        if (y == end()) {",
            "            x->p = INF;",
            "            return false;",
            "        }",
            "        if (x->m == y->m)",
            "            x->p = (x->b > y->b ? INF : -INF);",
            "        else",
            "            x->p = div(y->b - x->b, x->m - y->m);",
            "        return (x->p >= y->p);",
            "    }",
            "",
            "    /// Add line m*x + b.",
            "    void add(ll m, ll b) {",
            "        auto z = insert({m, b, 0}), y = z++, x = y;",
            "        while (isect(y, z))",
            "            z = erase(z);",
            "        if (x != begin() && isect(--x, y))",
            "            isect(x, y = erase(y));",
            "        while ((y = x) != begin() && (--x)->p >= y->p)",
            "            isect(x, erase(y));",
            "    }",
            "",
            "    /// Query maximum y-coordinate at given x.",
            "    ll query(ll x) {",
            "        assert(!empty());",
            "        auto l = *lower_bound(x);",
            "        return l.m * x + l.b;",
            "    }",
            "};",
            "$0"
        ],
        "description": "Container to add lines of the form m*x + b, and query maximum y-coordinates at given x."
    },
    "CP-RMQ": {
        "prefix": "RMQ",
        "body": [
            "/**",
            " * One-dimensional range minimum queries using a sparse table.",
            "*/",
            "template <typename T>",
            "struct RMQ {",
            "    /// jmp[lvl][j] stores the minimum value and index (ties broken leftwards) in [j, j + 2^lvl).",
            "    std::vector<std::vector<std::pair<T, int>>> jmp;",
            "    ",
            "    RMQ(const std::vector<T>& V) : jmp(1, std::vector<std::pair<T, int>>(V.size())) {",
            "        for (int i = 0; i < V.size(); ++i) ",
            "            jmp[0][i] = { V[i], i };",
            "        for (int pw = 1, k = 1; pw * 2 <= static_cast<int>(V.size()); pw *= 2, ++k) {",
            "            jmp.emplace_back(static_cast<int>(V.size()) - pw * 2 + 1);",
            "            for (int j = 0; j < jmp[k].size(); ++j) ",
            "                jmp[k][j] = min(jmp[k - 1][j], jmp[k - 1][j + pw]);",
            "        }",
            "    }",
            "",
            "    /// Queries are inclusive over [l, r].",
            "    std::pair<T, int> query(int l, int r) {",
            "        assert (l <= r);",
            "        int lvl = 31 - __builtin_clz(r - l + 1);",
            "        return min(jmp[lvl][l], jmp[lvl][r - (1 << lvl) + 1]);",
            "    }",
            "};",
            "$0"
        ],
        "description": "One-dimensional range minimum queries using a sparse table."
    },
    "CP-FENWICK": {
        "prefix": "FENWICK",
        "body": [
            "/**",
            " * Fenwick tree for range sums and point updates. 1-indexed internally.",
            "*/",
            "struct Fenwick {",
            "    int n;",
            "    std::vector<ll> bit;",
            "",
            "    Fenwick(int n) {",
            "        this->n = n + 1;",
            "        bit.assign(n + 1, 0LL);",
            "    }",
            "",
            "    Fenwick(std::vector<ll> a) : Fenwick(a.size()) {",
            "        for (size_t i = 0; i < a.size(); i++)",
            "            update(i, a[i]);",
            "    }",
            "",
            "    /// Returns the sum of the range [0, idx].",
            "    ll prefix(int idx) {",
            "        ll ret = 0LL;",
            "        for (++idx; idx > 0; idx -= idx & -idx)",
            "            ret += bit[idx];",
            "        return ret;",
            "    }",
            "",
            "    /// Returns the sum of the range [l, r].",
            "    ll sum(int l, int r) {",
            "        if (l > r) return 0LL;",
            "        if (l == 0) return prefix(r);",
            "        return prefix(r) - prefix(l - 1);",
            "    }",
            "",
            "    /// Adds `delta` to the value at index `idx`.",
            "    void update(int idx, ll delta) {",
            "        for (++idx; idx < n; idx += idx & -idx)",
            "            bit[idx] += delta;",
            "    }",
            "};"
        ],
        "description": "Fenwick tree for range sums and point updates."
    },
    "CP-SEGTREE": {
        "prefix": "SEGTREE",
        "body": [
            "template <typename T>",
            "T op(T a, T b) {",
            "    return a + b; // combine answers (any associative op)",
            "}",
            "",
            "template <typename T>",
            "T e() {",
            "    return 0; // initial value for queries (e.g. 0 for sum, -inf for max)",
            "}",
            "",
            "/**",
            " * Segment tree for range queries and point updates of any associative operation.",
            " * ",
            " * For example:",
            " *  `SegTree<ll, op, e> tree(a);`",
            " *  `tree.query(l, r); // range query [l,r]`",
            " *  `tree.update(pos, new_val); // point update`",
            "*/",
            "template <typename T, T(*op)(T, T), T(*e)()>",
            "class SegTree {",
            "public:",
            "    SegTree(int n) {",
            "        this->n = n;",
            "        tree.assign(4*n+1, e());",
            "    }",
            "",
            "    SegTree(std::vector<T> a) : SegTree(a.size()) {",
            "        build(a, 1, 0, n-1);",
            "    }",
            "",
            "    /// Queries are inclusive over [l, r].",
            "    T query(int l, int r) {",
            "        return query(1, 0, n-1, l, r);",
            "    }",
            "",
            "    /// Updates the value at index `pos` to `new_val`.",
            "    void update(int pos, T new_val) {",
            "        update(1, 0, n-1, pos, new_val);",
            "    }",
            "",
            "    void print() {",
            "        for (T x : tree) cout << x << \" \";",
            "        cout << nl;",
            "    }",
            "",
            "private:",
            "    int n;",
            "    std::vector<T> tree;",
            "",
            "    void build(std::vector<T>& a, int idx, int tl, int tr) {",
            "        if (tl > tr) return;",
            "        if (tl == tr) {",
            "            tree[idx] = a[tl];",
            "        } else {",
            "            int tm = (tl+tr)/2;",
            "            build(a, 2*idx, tl, tm);",
            "            build(a, 2*idx+1, tm+1, tr);",
            "            tree[idx] = op(tree[2*idx], tree[2*idx+1]);",
            "        }",
            "    }",
            "",
            "    T query(int idx, int tl, int tr, int l, int r) {",
            "        if (l > r) return e();",
            "        if (l == tl && r == tr) return tree[idx];",
            "        int tm = (tl+tr)/2;",
            "        return op(",
            "            query(2*idx, tl, tm, l, min(r, tm)),",
            "            query(2*idx+1, tm+1, tr, max(l, tm+1), r)",
            "        );",
            "    }",
            "",
            "    void update(int idx, int tl, int tr, int pos, T new_val) {",
            "        if (tl == tr) {",
            "            tree[idx] = new_val;",
            "        } else{",
            "            int tm = (tl+tr)/2;",
            "            if (pos <= tm) update(2*idx, tl, tm, pos, new_val);",
            "            else update(2*idx+1, tm+1, tr, pos, new_val);",
            "            tree[idx] = op(tree[2*idx], tree[2*idx+1]);",
            "        }",
            "    }",
            "};"
        ],
        "description": "Standard segment tree that supports range queries and point setting."
    },
    "CP-ERASTOSTHENES": {
        "prefix": "ERASTOSTHENES",
        "body": [
            "constexpr int MAX_PR = 1e7;",
            "std::bitset<MAX_PR> is_prime;",
            "",
            "// REMEMBER TO RUN THIS FUNCTION!",
            "void compute_primes() {",
            "    is_prime.set();",
            "    is_prime[0] = false;",
            "    is_prime[1] = false;",
            "",
            "    for (int i = 4; i < MAX_PR; i += 2)",
            "        is_prime[i] = false;",
            "",
            "    for (int i = 3; i * i < MAX_PR; i += 2)",
            "        if (is_prime[i])",
            "            for (int j = i * i; j < MAX_PR; j += i * 2)",
            "                is_prime[j] = 0;",
            "}",
            "$0"
        ],
        "description": "Sieve for generating primes up to `MAX_PR`."
    },
    "CP-MODINT": {
        "prefix": "MODINT",
        "body": [
            "/**",
            " * Allows easy integer modular arithmetic, modulo a constant prime.",
            "*/",
            "template <ll N>",
            "struct ModInt {",
            "    ll value;",
            "",
            "    ModInt(const ll x = 0) : value { x % N } {",
            "        if (value < 0) value += N;",
            "    }",
            "    ModInt(const ll n, const ll d) : value { 0 } {",
            "        *this += n; *this /= d;",
            "    }",
            "",
            "    ModInt operator+(const ModInt& other) const noexcept { return ModInt(*this) += other; }",
            "    ModInt operator-(const ModInt& other) const noexcept { return ModInt(*this) -= other; }",
            "    ModInt operator*(const ModInt& other) const noexcept { return ModInt(*this) *= other; }",
            "    ModInt operator/(const ModInt& other) const noexcept { return ModInt(*this) /= other; }",
            "",
            "    ModInt& operator+=(const ModInt& other) noexcept {",
            "        value += other.value;",
            "        if (value >= N) value -= N;",
            "        return *this;",
            "    }",
            "    ModInt& operator-=(const ModInt& other) noexcept {",
            "        value -= other.value;",
            "        if (value < 0) value += N;",
            "        return *this;",
            "    }",
            "    ModInt& operator*=(const ModInt& other) noexcept {",
            "        value = value * other.value % N;",
            "        return *this;",
            "    }",
            "    ModInt& operator/=(const ModInt& other) noexcept {",
            "        return *this *= other.inv();",
            "    }",
            "",
            "    ModInt pow(ll e) const noexcept {",
            "        ModInt res(1), tmp(*this);",
            "        while (e) {",
            "            if (e & 1) res *= tmp;",
            "            tmp *= tmp;",
            "            e >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "    ModInt inv() const noexcept {",
            "        return pow(N - 2);",
            "    }",
            "",
            "    explicit operator int() const { return value; }",
            "    friend std::ostream& operator<<(std::ostream& os, const ModInt& obj) {",
            "        return os << obj.value;",
            "    }",
            "    friend std::istream& operator>>(std::istream& is, ModInt& obj) {",
            "        ll t; is >> t;",
            "        obj = ModInt(t);",
            "        return is;",
            "    }",
            "};",
            "constexpr int MOD = 1e9 + 7; // CHANGE!",
            "using MI = ModInt<MOD>;"
        ],
        "description": "Allows easy integer modular arithmetic, modulo a constant prime."
    },
    "CP-DSU": {
        "prefix": "DSU",
        "body": [
            "/**",
            " * Disjoint set union with path compression and union by size.",
            "*/",
            "class DSU {",
            "public:",
            "    DSU(int n) {",
            "        m_parent.resize(n);",
            "",
            "        m_size.resize(n, 1);",
            "        for (int i = 0; i < n; ++i) {",
            "            m_parent[i] = i;",
            "        }",
            "    }",
            "",
            "    /// Returns the root of the set containing x.",
            "    int find(int x) {",
            "        if (m_parent[x] != x) {",
            "            // Path compression",
            "            m_parent[x] = find(m_parent[x]);",
            "        }",
            "        return m_parent[x];",
            "    }",
            "",
            "    /// Unites the sets containing x and y.",
            "    bool unite(int x, int y) {",
            "        int root_x = find(x);",
            "        int root_y = find(y);",
            "",
            "        if (root_x == root_y) return false;",
            "",
            "        // Union by size",
            "        if (m_size[root_x] < m_size[root_y]) {",
            "            m_parent[root_x] = root_y;",
            "            m_size[root_y] += m_size[root_x];",
            "        } else {",
            "            m_parent[root_y] = root_x;",
            "            m_size[root_x] += m_size[root_y];",
            "        }",
            "        return true;",
            "    }",
            "",
            "    /// Returns true if x and y are in the same set.",
            "    bool sameSet(int x, int y) {",
            "        return find(x) == find(y);",
            "    }",
            "",
            "    /// Returns the size of the set containing x.",
            "    int getSize(int x) {",
            "        return m_size[find(x)];",
            "    }",
            "",
            "private:",
            "    std::vector<int> m_parent;",
            "    std::vector<int> m_size;",
            "};"
        ],
        "description": "Disjoint set union with path compression and union by size."
    },
    "CP-GOSPERHACK": {
        "prefix": "GOSPERHACK",
        "body": [
            "// http://programmingforinsomniacs.blogspot.com/2018/03/gospers-hack-explained.html",
            "int set = (1 << k) - 1;",
            "int limit = (1 << n);",
            "while (set < limit) {",
            "    // use the subset",
            "    $0",
            "",
            "    int c = set & -set;",
            "    int r = set + c;",
            "    set = (((r ^ set) >> 2) / c) | r;",
            "}"
        ],
        "description": "Iterates through all subsets of size `k` from `n` elements using bitmasks in increasing order."
    }
}